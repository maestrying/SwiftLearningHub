# Оглавление
1. [Основы Swift](#основы-swift)
    - [var vs let](#var-vs-let)
    - [Основные типы данных](#основные-типы-данных)
    - [Действия со строками](#действия-со-строками)
2. [Операторы диапазона](#операторы-диапазона)
    - [Оператор замкнутого диапазона](#оператор-замкнутого-диапазона)
    - [Оператор полузамкнутого диапазона](#оператор-полузамкнутого-диапазона)
    - [Односторонние диапазоны](#односторонние-диапазоны)
3. [Инструкция if](#инструкция-if)
4. [Инструкция switch](#инструкция-switch)

## Основы Swift
### `var` vs `let`

- `var`: Для переменных. Значение может быть изменено.
- `let`: Для констант. Значение не может быть изменено после инициализации.
```swift
var variable = "Изменяемая"
let constant = "Неизменяемая"
```

### Основные типы данных
- `Character` - символ
- `String` - текстовая строка
- `Int` - целое число
- `UInt` - беззнаковый тип целого числа
- `Float` - 32-битное число с плавающей точкой
- `Double` - 64-битное число с плавающей точкой
- `Bool` - логическое значение (true/false)

Вы можете добавить обозначение типа, когда объявляете константу или переменную, чтобы иметь четкое представление о типах значений, которые могут хранить константы или переменные, но это необязательно.

> **Примечание**  
>
> В случае с `Character`, `UInt` и `Double` тип данных необходимо задавать явно.

Пример явного обозначения типа:
```swift
// «Объяви переменную с именем welcomeMessage, тип которой будет String»
var welcomeMessage: String
```

Для изменения типа данных переменной в Swift используется процесс, известный как "type casting" (приведение типов):
```swift
let initialNumber = 123
let stringNumber = String(initialNumber) // Преобразование Int в String
```

### Действия со строками
#### Конкатенация
Значения типа `String` могут быть добавлены или конкатенированы с помощью оператора сложения (`+`):
```swift
let string1 = "hello"
let string2 = " there"
var welcome = string1 + string2
// welcome равен "hello there"
```

#### Интерполяция
Способ создать новое значение типа `String` из разных констант:
```swift
let multiplier = 3
let message = "\(multiplier) times 2.5 is \(Double(multiplier) * 2.5)"
// "3 times 2.5 is 7.5"
```

## Операторы диапазона
В языке Swift есть два оператора диапазона, которые в короткой форме задают диапазон значений

### Оператор замкнутого диапазона
Оператор замкнутого диапазона (`a...b`) задает диапазон от `a` до `b`, включая сами `a` и `b`. При этом значение `a` не должно превышать `b`.

Оператор замкнутого диапазона удобно использовать при последовательном переборе значений из некоторого диапазона, как, например, в цикле `for-in`:
```swift
for index in 1...5 {
    print("\(index) умножить на 5 будет \(index * 5)")
}
// 1 умножить на 5 будет 5
// 2 умножить на 5 будет 10
// 3 умножить на 5 будет 15
// 4 умножить на 5 будет 20
// 5 умножить на 5 будет 25
```

### Оператор полузамкнутого диапазона
Оператор полузамкнутого диапазона (`a..<b`) задает диапазон от `a` до `b`, исключая значение `b`. Такой диапазон называется полузамкнутым, потому что он включает первое значение, но исключает последнее

Операторы полузамкнутого диапазона особенно удобны при работе с массивами и другими последовательностями, пронумерованными с нуля, когда нужно перебрать элементы от первого до последнего:
```swift
let names = ["Anna", "Alex", "Brian", "Jack"]
let count = names.count

for i in 0..<count {
    print("Person \(i + 1) будет \(names[i])")
}
// Person 1 будет Anna
// Person 2 будет Alex
// Person 3 будет Brian
// Person 4 будет Jack
```

### Односторонние диапазоны
Операторы замкнутого диапазона имеют себе альтернативу - это диапазон, который продолжается насколько возможно, но только в одну сторону:
```swift
let names = ["Anna", "Alex", "Brian", "Jack"]

for name in names[2...] {
    print(name)
}
// Brian
// Jack
```

Оператор полузамкнутого диапазона так же имеет одностороннюю форму, которая записывается только с одним конечным значением:
```swift
for name in names[..<2] {
    print(name)
}
// Anna
// Alex
```

Вы так же можете проверить имеет ли односторонний диапазон конкретное значение:
```swift
let range = ...5
range.contains(7)   // false
range.contains(4)   // true
range.contains(-1)  // true
```

## Инструкция if
Каждый оператор сравнения возвращает значение типа Bool, указывающее, является ли выражение истинным:
```swift
let name = "world"

if name == "world" {
    print("hello, world")
} else if name == "Max" {
    print("hello, Max")
} else {
    print("Мне жаль, \(name), но я тебя не узнаю")
}
// напечатает "hello, world"
```

Так же можно сравнивать кортежи, которые имеют одно и то же количество значений, которые, в свою очередь, должны быть сравниваемыми, что означает, что кортеж типа (`Int`, `String`) может быть сравнен с кортежем такого же типа.

Кортежи сравниваются слева направо, по одному значению за раз до тех пор, пока операция сравнения не найдет отличия между значениями. Если все значения кортежей попарно равны, то и кортежи так же считаются равными
```swift
(1, "zebra") < (2, "apple")   // true, потому что 1 меньше 2, "zebra" и "apple" не сравниваются
(3, "apple") < (3, "bird")    // true , потому что 3 равно 3, а "apple" меньше чем "bird"
(4, "dog") == (4, "dog")      // true , потому что 4 равно 4 и "dog" равен "dog"
```

## Инструкция switch
`Switch` подразумевает наличие какого-то значения, которое сравнивается с несколькими возможными шаблонами. После того как значение совпало с каким-либо шаблоном, выполняется код, соответствующий ответвлению этого шаблона, и больше сравнений уже не происходит. `Switch` представляет собой альтернативу инструкции `if`, отвечающей нескольким потенциальным значениям:
```swift
let fruit = "apple"

switch fruit {
case "apple":
    print("Это яблоко.")
case "banana":
    print("Это банан.")
case "orange":
    print("Это апельсин.")
default:
    print("Неизвестный фрукт.")
}
// Это яблоко.
```
